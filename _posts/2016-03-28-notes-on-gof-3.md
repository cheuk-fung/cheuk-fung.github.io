---
layout: post
title: GoF 閱讀筆記（Behavioral Patterns）
---

Behavioral Patterns 除了關注類型與對象的組織結構外，還關注對象之間的通訊。這是 _GoF_ 介紹的最後一類設計模式。

### Chain of Responsibility 責任鏈

責任鏈解耦了請求的發送者和接收者。發送者不需要知道所有可能的接收者，它只需要將請求發送給一個接收者，這個接收者如果不處理這個請求就會請它傳送給下一個接收者，如此往復直至有一個接收者處理了這個請求或沒有接收者了。所有的接收者連成了一條鏈。

### Command 命令

命令模式將請求封裝成一個對象，從而可以方便地記錄請求的參數和狀態，也可以為請求增加排隊、日志等功能。

### Interpreter 直譯器

直譯器用於解釋並執行自定義的語言。沒想到直譯器也是一种「模式」。

### Iterator 迭代器

迭代器用於順序訪問一個集合類中的元素。從迭代的控制權來看，迭代器可分為兩種：

- external iterator 外迭代器：由使用者顯式遍歷迭代器。

```java
Iterator<T> iterator = collection.iterator();
while (iterator.hasNext()) {
    T element = iterator.next();
    ...
}
```

- internal iterator 內迭代器：迭代器接收一個操作並應用到集合類的元素。內迭代器對於支持 lambda 表逹式的語言特別有用，所幸 Java 8 已支持 lambda 表逹式。

```java
collection.stream().map(e -> ...);
```

### Mediator 中介者

創建一個對象作為中介者，其它對象通過它進行通訊。MVC 中的 Controller 可以實現為中介者，Model 和 View 之間完全通過它通訊。

### Memento 備忘錄

生成一個額外的「備忘錄」對象用於保存一個對象的內部狀態，便於將這個對象恢復到先前的某個狀態而又不破壞封裝。適用於支持 `redo` 操作。

### Observer 觀察者

觀察者又稱為 Publish-Subscribe 發佈-訂閱。在消息的發佈者和訂閱者間形成鬆耦合，雙方不需知道對方的存在，而是用「消息」將雙方關聯起來。Kafka 就是這樣一種模式。

### State 狀態

如果一個對象的行為因內部狀態改變而不同，可以將內部狀態和相關的行為一起封裝為一個新的對象，原對象將這些行為委托給狀態對象。狀態轉移既可以由原對象控制，也可以由狀態對象控制。

### Strategy 策略

策略模式將一系列的算法封裝為對象，使用者可按需選擇不同的策略執行。與狀態模式一樣，使用者都將一些方法或行為委托給了另一個對象。但不同的是，策略模式中不同的策略在於算法不同，並沒有依賴關係；而狀態模式中不同的狀態之間會按一定的規則轉移，不同的狀態表現出不同的行為。

### Template Method 模板方法

模板方法實現一個算法或流程的框架，並把一些步驟抽出來讓子類實現或提供缺省實現讓子類重寫。模板方法的應用很廣泛，但應用於較深層次的類型結構中就會很煩，一是實現時視野集中在局部，了解算法的全部流程時容易繞暈；再者多層模板之後會難以命名。

### Visitor 訪問者

訪問者模式將需要應用於一個類型結構中的每一個類型的操作抽象為一套接口，每一個類型在接收到訪問者時調用訪問者中對應這個類型的接口。比如需要對一棵解析樹進行類型檢查、代碼優化等操作時，便可用將不同的操作實現為不同的訪問者，解析樹中的每個結點在接受訪問者時調用訪問者中操作這個結點的接口。
