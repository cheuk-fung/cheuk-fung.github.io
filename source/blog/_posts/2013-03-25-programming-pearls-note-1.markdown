---
layout: blog
title: "Programming Pearls Note #1"
location: NKU, China
post: true

excerpt: "「空間壓縮」和「時間換空間」的思考"
---

每周都有一些零碎的時間無事可做，在學長的書櫃裡翻書時看到想看很久的《編程珠璣》，正好用来填充這些時間。零零碎碎，大概會看得很慢吧。

第一章描述的「很簡單」的問題就值得好好思考。問題大概是這樣的：

> 給一個最多包含一千萬個小於一千萬且不重複的正整數的文件排序。最多只能使用 **1MB** 內存。

顯然，**1MB** 內存是個很重要的限制條件，這直接决定了我們無法把所有數據讀入內存再使用諸如快速排序、合併排序等演算法處理，甚至使用一個整型来存儲一個數都覺得「奢侈」。這就是需要思考的地方。

在 ACM-ICPC 的訓練中，遇到內存不夠用時，我們會考慮采用*位操作 (bitwise operation)* 解決。位操作的優點是可以大大的壓縮空間，並通常可以加速運行。但它的限制很多，如數據範圍小、數據集小、無重複數據等，這題是否也適用這种方法呢？書中給了解答，是的，這題滿足位操作的限制。唯一的麻煩是 1MB 的位圖只能表示大概 800 萬個整數，想要容下全部 1000 萬個數，我們需要把內存限制放寬到 **1.25MB**。書中沒有給出位操作的實現細節，而是留為了習題（習題 2）。我的實現如下（使用 C 語言）：

~~~ c
#include <stdio.h>

#define MAX_N	10000000
#define SHIFT	5
#define MASK	0x1F

int bitmap[MAX_N / (1 << SHIFT)];

void set(int x) { bitmap[x >> SHIFT] |= 1 << (x & MASK); }
int test(int x) { return bitmap[x >> SHIFT] & (1 << (x & MASK)); }

int main(int argc, char *argv[])
{
    int i;
    while (~scanf("%d", &i)) {
        set(i);
    }

    for (i = 0; i < MAX_N; i++) {
        if (test(i)) {
            printf("%d\n", i);
        }
    }

    return 0;
}
~~~

如果一定只能用 1MB 內存呢（習題 5）？受 1.3 節的「40 趟演算法」的啟發，我們可以設計「兩趟演算法」：使用前面的位操作演算法，第一趟排 \[0, 5,000,000) 範圍內的數，第二趟排 \[5,000,000，10,000,000) 範圍內的。`bitmap` 的大小減少了一半，佔用內存甚至少於 1MB ，不過運算時間翻倍了。這是典型的「時間換空間」的策略。
