<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>The Stars My Destination</title>
    <link href="http://leewings.github.io/atom.xml" rel="self"/>
    <link href="http://leewings.github.io"/>
    <updated>2014-02-25T11:42:49+00:00</updated>
    <id>http://leewings.github.io</id>
    <author>
        <name>Ng Cheuk-fung</name>
        <email>osideal@gmail.com</email>
    </author>

    
    <entry>
        <title>Programming Pearls Note #2</title>
        <link href="http://leewings.github.io/blog/programming-pearls-note-2.html"/>
        <updated>2013-04-01T00:00:00+00:00</updated>
        <id>id:/blog/programming-pearls-note-2</id>
        <content type="html">&lt;p&gt;第二章提出的三個問題很有趣，特別是問題 B，解法真是巧妙。每個問題都有可做筆記之處，一一記之。&lt;/p&gt;

&lt;h3 id=&quot;a&quot;&gt;問題 A&lt;/h3&gt;
&lt;p&gt;二分法的威力在於它的時間複雜度為 $O(\log n)$，隨著規模的增大，時間增長極其緩慢。40 億個數中搜索缺少的一個，最壞也只用扫描 32 遍就找到了；而且利用臨時文件，每次就只需扫描前次的一半。&lt;/p&gt;

&lt;p&gt;其難點在於尋找二分的對象，有時不是那麼顯然，往往需要靈機一動的時刻。&lt;/p&gt;

&lt;h3 id=&quot;b&quot;&gt;問題 B&lt;/h3&gt;
&lt;p&gt;簡言之，這個問題是：如何交換字串的兩部份，即使 &lt;code&gt;ab&lt;/code&gt; 變為 &lt;code&gt;ba&lt;/code&gt;？書中的解法讓我驚嘆不已：先各自翻轉 &lt;code&gt;ab&lt;/code&gt;，形成 $a^{-1}b^{-1}$，再一起翻轉。巧妙之處在於其原理非常地簡洁，$(a^{-1}b^{-1})^{-1} = (b^{-1})^{-1}(a^{-1})^{-1} = ba$。Ken Thompson 認為這應當是一種常識……&lt;/p&gt;

&lt;p&gt;如果讓我回到一年級，我一定說：好好學習「線性代數」。&lt;/p&gt;

&lt;h3 id=&quot;c&quot;&gt;問題 C&lt;/h3&gt;
&lt;p&gt;尋找字典中所有的變位詞，兩兩比較的時間複雜度為 $O(n^{2})$，然而字典中條目衆多，這樣要算很久。我想了兩個辦法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;同一類變位詞中的單詞長度相等。&lt;/strong&gt;那麼我們可以對字典按單詞長度排序，比較時只有比較同長度的。但是，這樣還是可以很輕易構造出使其退化為 $O(n^{2})$ 的字典。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;同一個變位詞中一個單詞所含的字母种類和數量相同。&lt;/strong&gt;我們可以依此構造雜湊函式，但需要解决碰撞問題，寫起來蠻麻煩的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;咦？為甚麼要雜湊呢？排序呀！啊哈！靈機一動。實際上，第二條性質隠含了第一條，也更為本質地反應了變位詞的特性。我們只需這樣做：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;將每個單詞中的字母按照字母序重新排序，同一類變位詞將拥有一個相同的序列。&lt;/li&gt;
  &lt;li&gt;將新的序列按字典序排序，同一類變位詞將聚集到一起。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;運用兩次排序即可，演算法如此簡單。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Programming Pearls Note #1</title>
        <link href="http://leewings.github.io/blog/programming-pearls-note-1.html"/>
        <updated>2013-03-25T00:00:00+00:00</updated>
        <id>id:/blog/programming-pearls-note-1</id>
        <content type="html">&lt;p&gt;每周都有一些零碎的時間無事可做，在學長的書櫃裡翻書時看到想看很久的《編程珠璣》，正好用来填充這些時間。零零碎碎，大概會看得很慢吧。&lt;/p&gt;

&lt;p&gt;第一章描述的「很簡單」的問題就值得好好思考。問題大概是這樣的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;給一個最多包含一千萬個小於一千萬且不重複的正整數的文件排序。最多只能使用 &lt;strong&gt;1MB&lt;/strong&gt; 記憶體。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;顯然，&lt;strong&gt;1MB&lt;/strong&gt; 記憶體是個很重要的限制條件，這直接决定了我們無法把所有資料讀入記憶體再使用諸如快速排序、合併排序等演算法處理，甚至使用一個 &lt;code&gt;int&lt;/code&gt; 来存儲一個數都覺得「奢侈」。這就是需要思考的地方。&lt;/p&gt;

&lt;p&gt;在 ACM-ICPC 的訓練中，遇到記憶體不夠用時，我們會考慮采用&lt;em&gt;位操作 (bitwise operation)&lt;/em&gt; 解決。位操作的優點是可以大大的壓縮空間，並通常可以加速運行。但它的限制很多，如資料範圍小、資料集小、無重複資料等，這題是否也適用這种方法呢？書中給了解答，是的，這題滿足位操作的限制。唯一的麻煩是 1MB 的位圖只能表示大概 800 萬個整數，想要容下全部 1000 萬個數，我們需要把記憶體限制放寬到 &lt;strong&gt;1.25MB&lt;/strong&gt;。書中沒有給出位操作的實現細節，而是留為了習題（習題 2）。我的實現如下（使用 C 語言）：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#579&quot;&gt;#include&lt;/span&gt; &lt;span style=&quot;color:#B44;font-weight:bold&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span style=&quot;color:#579&quot;&gt;#define&lt;/span&gt; MAX_N &lt;span style=&quot;color:#00D&quot;&gt;10000000&lt;/span&gt;
&lt;span style=&quot;color:#579&quot;&gt;#define&lt;/span&gt; SHIFT &lt;span style=&quot;color:#00D&quot;&gt;5&lt;/span&gt;
&lt;span style=&quot;color:#579&quot;&gt;#define&lt;/span&gt; MASK  &lt;span style=&quot;color:#02b&quot;&gt;0x1F&lt;/span&gt;

&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; bitmap[MAX_N / (&lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHIFT)];

&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;void&lt;/span&gt; set(&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; x) { bitmap[x &amp;gt;&amp;gt; SHIFT] |= &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (x &amp;amp; MASK); }
&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; test(&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; x) { &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; bitmap[x &amp;gt;&amp;gt; SHIFT] &amp;amp; (&lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (x &amp;amp; MASK)); }

&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; main(&lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; argc, &lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;char&lt;/span&gt; *argv[])
{
    &lt;span style=&quot;color:#0a5;font-weight:bold&quot;&gt;int&lt;/span&gt; i;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;while&lt;/span&gt; (~scanf(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;%d&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;i)) {
        set(i);
    }

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;for&lt;/span&gt; (i = &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;; i &amp;lt; MAX_N; i++) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (test(i)) {
            printf(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;%d&lt;/span&gt;&lt;span style=&quot;color:#b0b&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, i);
        }
    }

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果一定只能用 1MB 記憶體呢（習題 5）？受 1.3 節的「40 趟演算法」的啟發，我們可以設計「兩趟演算法」：使用前面的位操作演算法，第一趟排 [0, 5,000,000) 範圍內的數，第二趟排 [5,000,000，10,000,000) 範圍內的。&lt;code&gt;bitmap&lt;/code&gt; 的大小減少了一半，記憶體佔用甚至少於 1MB ，不過運算時間翻倍了。這是典型的「時間換空間」的策略。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>紅寶石學習筆記（四）</title>
        <link href="http://leewings.github.io/blog/notes-on-learning-ruby-4.html"/>
        <updated>2013-01-25T00:00:00+00:00</updated>
        <id>id:/blog/notes-on-learning-ruby-4</id>
        <content type="html">&lt;h2 id=&quot;misc&quot;&gt;Misc&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;||= 運算子&lt;/h3&gt;
&lt;p&gt;由於 &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt; 等運算子的語義，&lt;code&gt;a ||= b&lt;/code&gt; 可能會被理解成 &lt;code&gt;a = a || b&lt;/code&gt;。
但實際上，Ruby 將其實現為 &lt;code&gt;a || a = b&lt;/code&gt;，
這樣當 &lt;code&gt;a&lt;/code&gt; 為真（即不為 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;）的時候就不會執行賦值操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html&quot;&gt;&lt;em&gt;What Ruby’s ||= (Double Pipe / Or Equals) Really Does&lt;/em&gt;&lt;/a&gt;
這篇文章的一個測試非常好：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;h = {}

&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; h.&lt;span style=&quot;color:#06B;font-weight:bold&quot;&gt;[]=&lt;/span&gt;(k, v)
  puts &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Setting hash key &lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,0%,0%,0.07);color:black&quot;&gt;&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;#{&lt;/span&gt;k&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt; with &lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,0%,0%,0.07);color:black&quot;&gt;&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;#{&lt;/span&gt;v.inspect&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;super&lt;/span&gt;
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;

&lt;span style=&quot;color:#777&quot;&gt;# 1. The standard ||= approach&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:x&lt;/span&gt;] ||= &lt;span style=&quot;color:#00D&quot;&gt;10&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:x&lt;/span&gt;] ||= &lt;span style=&quot;color:#00D&quot;&gt;20&lt;/span&gt;

&lt;span style=&quot;color:#777&quot;&gt;# 2. The a = a || b approach&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:y&lt;/span&gt;] = h[&lt;span style=&quot;color:#A60&quot;&gt;:y&lt;/span&gt;] || &lt;span style=&quot;color:#00D&quot;&gt;10&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:y&lt;/span&gt;] = h[&lt;span style=&quot;color:#A60&quot;&gt;:y&lt;/span&gt;] || &lt;span style=&quot;color:#00D&quot;&gt;20&lt;/span&gt;

&lt;span style=&quot;color:#777&quot;&gt;# 3. The a || a = b approach&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:z&lt;/span&gt;] || h[&lt;span style=&quot;color:#A60&quot;&gt;:z&lt;/span&gt;] = &lt;span style=&quot;color:#00D&quot;&gt;10&lt;/span&gt;
h[&lt;span style=&quot;color:#A60&quot;&gt;:z&lt;/span&gt;] || h[&lt;span style=&quot;color:#A60&quot;&gt;:z&lt;/span&gt;] = &lt;span style=&quot;color:#00D&quot;&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;輸出為：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Setting hash key x with 10
Setting hash key y with 10
Setting hash key y with 10
Setting hash key z with 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;還有一個 &lt;code&gt;&amp;amp;&amp;amp;=&lt;/code&gt; 運算子，類似地，語義是 &lt;code&gt;a &amp;amp;&amp;amp; a = b&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;for-&quot;&gt;for 的視野&lt;/h3&gt;
&lt;p&gt;出乎意料，&lt;code&gt;for&lt;/code&gt; 並沒有開啟一個新的視野（与 &lt;code&gt;each&lt;/code&gt; 不同），
所以在 &lt;code&gt;for&lt;/code&gt; 的區塊中定義的變數會被外部看到。
因此，&lt;a href=&quot;https://github.com/styleguide/ruby&quot;&gt;&lt;em&gt;Ruby 風格指南&lt;/em&gt;&lt;/a&gt; 中建議使用迭代器 (iterator) 取代之。&lt;/p&gt;

&lt;p&gt;類似的 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; 等也沒有開啟新的視野。&lt;/p&gt;

&lt;h3 id=&quot;heredoc&quot;&gt;heredoc&lt;/h3&gt;
&lt;p&gt;可以使用 heredoc 為字串賦值：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;hello = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;lt;&amp;lt;END&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#D20&quot;&gt;
hello, world&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;
END&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但是這樣就不好看了：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; something
  hello = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;lt;&amp;lt;END&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#D20&quot;&gt;
hello, world&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;
END&lt;/span&gt;&lt;/span&gt;
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;這樣好看一點（&lt;code&gt;END&lt;/code&gt; 前多了一個 &lt;code&gt;-&lt;/code&gt;）：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; something
  hello = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;lt;&amp;lt;-END&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#D20&quot;&gt;
hello, world&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;
  END&lt;/span&gt;&lt;/span&gt;
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;更好看一點？有點 trick… ：&lt;/p&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; something
  hello = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;lt;&amp;lt;-END&lt;/span&gt;&lt;/span&gt;.gsub(&lt;span style=&quot;background-color:hsla(300,100%,50%,0.06)&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#808&quot;&gt;^ {4}&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#D20&quot;&gt;
    hello, world&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;
  END&lt;/span&gt;&lt;/span&gt;
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </entry>
    
    <entry>
        <title>紅寶石學習筆記（三）</title>
        <link href="http://leewings.github.io/blog/notes-on-learning-ruby-3.html"/>
        <updated>2012-11-25T00:00:00+00:00</updated>
        <id>id:/blog/notes-on-learning-ruby-3</id>
        <content type="html">&lt;h2 id=&quot;ruby-httpguidesrubytwruby&quot;&gt;&lt;a href=&quot;http://guides.ruby.tw/ruby/&quot;&gt;Ruby 使用手冊&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;變數&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通過前綴區分全域、實例、區域三種變數，確實是個好辦法。&lt;/li&gt;
  &lt;li&gt;實例變數從不公開，封裝更徹底了；不过實例常數是公開的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;常數&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;更改常數會出現警告而不是錯誤，所以，常數是能改的……我想知道為甚麼會這樣設計。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;例外處理：救援&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用 &lt;code&gt;retry&lt;/code&gt; 很容易該程式碼無限迴圈，我猜這就是為甚麼現在 &lt;code&gt;retry&lt;/code&gt; 必須和 &lt;code&gt;rescue&lt;/code&gt; 一起用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;存取器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;不明白為什麼會有 &lt;code&gt;attr_reader&lt;/code&gt;, &lt;code&gt;attr_writer&lt;/code&gt; 這類的「快捷方式」，使用起來就像在直接訪問實例變數，那和把它公開了有甚麼區別？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算是基本了解 Ruby 是怎麼玩的咯~這本手冊很多東西都是點到即止，Ruby 的世界應該還大著吧！&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>紅寶石學習筆記（二）</title>
        <link href="http://leewings.github.io/blog/notes-on-learning-ruby-2.html"/>
        <updated>2012-11-25T00:00:00+00:00</updated>
        <id>id:/blog/notes-on-learning-ruby-2</id>
        <content type="html">&lt;h2 id=&quot;ruby-httpguidesrubytwruby&quot;&gt;&lt;a href=&quot;http://guides.ruby.tw/ruby/&quot;&gt;Ruby 使用手冊&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;物件導向思維&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;“Object oriented” 譯成「物件導向」似乎比「面象對象」更為達意些。&lt;/li&gt;
  &lt;li&gt;在 Ruby 裡任何東西都是物件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;呼叫方法時，如果不會造成歧義，可以省略引數的括號。可是這樣會降低程式碼的可讀性吧？&lt;/li&gt;
  &lt;li&gt;好吧，定義方法時，引數的括號也可以省略……&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;存取控制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Object&lt;/code&gt; 類別是所有類別的父類別，不在任何一個類別中定義的「函數」其實是它的&lt;strong&gt;私有&lt;/strong&gt;方法，所以 Ruby 是&lt;strong&gt;純物件導向語言&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;雖然所有類別從 &lt;code&gt;Object&lt;/code&gt; 類別繼承了這些方法，但由於它們是私有方法，所以只能以函數的方式呼叫出來。&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;&lt;code&gt;private:method&lt;/code&gt; 冒號後面不能加空格……&lt;/del&gt;&lt;br /&gt;
有種東西叫字串符号 (Symbol)，它是一個可識別的名字而不是字串，所以這裡更好的寫法是：&lt;code&gt;private :method&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;單件方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;只給予單一物件的方法，竟然有這麼神奇的東西！應該是支援多態的一種方式吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模組&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby 只支援單一繼承，但可以利用模組實現「受限制的多重繼承」，稱之為「混入 (mixin)」。這樣既滿足了對多重繼承的基本需求，又使得繼承關係不至於過份複雜。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;程序物件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Proc.new&lt;/code&gt; 和 &lt;code&gt;lambda&lt;/code&gt; 的區別：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#06B;font-weight:bold&quot;&gt;foo&lt;/span&gt;
        x = &lt;span style=&quot;color:#036;font-weight:bold&quot;&gt;Proc&lt;/span&gt;.new { &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;I am foo.&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; }
        puts x.call
        puts &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;foo ends.&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#06B;font-weight:bold&quot;&gt;bar&lt;/span&gt;
        x = lambda { &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;I am bar.&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; }
        puts x.call
        puts &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;bar ends.&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;

    foo
    bar
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;產生的輸出是：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  I am bar.
  bar ends.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Got it?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>紅寶石學習筆記（一）</title>
        <link href="http://leewings.github.io/blog/notes-on-learning-ruby-1.html"/>
        <updated>2012-11-24T00:00:00+00:00</updated>
        <id>id:/blog/notes-on-learning-ruby-1</id>
        <content type="html">&lt;h2 id=&quot;ruby-httpguidesrubytwruby&quot;&gt;&lt;a href=&quot;http://guides.ruby.tw/ruby/&quot;&gt;Ruby 使用手冊&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;簡單示範&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;函數會回傳最後計算的結果，因此有時可以省略 &lt;code&gt;return&lt;/code&gt; 敘述。&lt;/li&gt;
  &lt;li&gt;命令列引數存在 &lt;code&gt;ARGV&lt;/code&gt; 陣列裡，並且 &lt;code&gt;ARGV[0]&lt;/code&gt; 是程式的&lt;strong&gt;第一個引數&lt;/strong&gt;而非程式的名稱。程式的名稱是全局變數 &lt;code&gt;$0&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;Ruby 的世界裡好像是用兩個空格縮進的呢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;字串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;沒有 &lt;code&gt;char&lt;/code&gt; 型別，單引號括起的即是字串本身，不處理逸出 (escape) 字元，也不使用 &lt;code&gt;#{}&lt;/code&gt; 計算裡面的程式；雙引號括起的字串則會。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;正規表示式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;匹配運算子：&lt;code&gt;=~&lt;/code&gt;，一邊是字串，另一邊是正規表示式；如果匹配則會傳回匹配的開始位置，否則傳回 &lt;code&gt;nil&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;還有不匹配運算子：&lt;code&gt;!~&lt;/code&gt;，回傳值是布林值。&lt;/li&gt;
  &lt;li&gt;這兩個運算子滿足交換律。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;陣列&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ary[x, y]&lt;/code&gt; 傳回包含從第 x 個項目開始連續 y 個項目的陣列，&lt;code&gt;x &amp;lt; 0&lt;/code&gt; 的話是指陣列倒數第 &lt;code&gt;|x|&lt;/code&gt; 個項目。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ary[x..y]&lt;/code&gt; 傳回包含從第 x 個項目到第 y 個項目的陣列；如果 x 項目在 y 項目後面，就傳回 &lt;code&gt;[]&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;原來 “hash” 翻譯成「雜湊」，好神奇……另，「雜湊」又稱「關聯陣列 (associative array)」或「字典 (dictionary)」。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;継續簡單示範&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;puts&lt;/code&gt; 的區別類似 Java 中的 &lt;code&gt;System.out.print&lt;/code&gt; 和 &lt;code&gt;System.out.println&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;習慣上，在方法名稱後加上驚嘆號（&lt;code&gt;!&lt;/code&gt;, “bang!”）暗示有某種副作用（如可能改變物件的內容），加上問號（&lt;code&gt;?&lt;/code&gt;, “huh?”）暗示回傳值為布林值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;控制結構&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;測試真值時，除了 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 之外的東西都視為真。（&lt;strong&gt;&lt;code&gt;0&lt;/code&gt; 也是「真」！&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;case&lt;/code&gt; 內部使用「關聯運算子（relationship operator）」&lt;code&gt;===&lt;/code&gt;，可以一次檢查數個條件。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;===&lt;/code&gt; 左邊是一般物件時與 &lt;code&gt;==&lt;/code&gt; 一樣，而左邊是範圍表示式或正規表示式時就會測試右邊是不是在左邊的範圍內或是否符合左邊的正規表示式。所以 &lt;code&gt;===&lt;/code&gt; 不滿足交換律：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    irb(main):&lt;span style=&quot;color:#00D&quot;&gt;001&lt;/span&gt;:&lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;&amp;gt; &lt;span style=&quot;background-color:hsla(300,100%,50%,0.06)&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#808&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;/span&gt; === &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;abcdefg&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    =&amp;gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;
    irb(main):&lt;span style=&quot;color:#00D&quot;&gt;002&lt;/span&gt;:&lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;&amp;gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;abcdefg&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; === &lt;span style=&quot;background-color:hsla(300,100%,50%,0.06)&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#808&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;/&lt;/span&gt;&lt;/span&gt;
    =&amp;gt; &lt;span style=&quot;color:#069&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;next&lt;/code&gt; 相當於 C 中的 &lt;code&gt;continue&lt;/code&gt;；比 C 多了個可以重新開始當前迴圈的 &lt;code&gt;redo&lt;/code&gt;，這個蠻方便的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;迭代器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;貌似是從 Ruby 1.9 以後，&lt;code&gt;retry&lt;/code&gt; 必須要和 &lt;code&gt;rescue&lt;/code&gt; 一起用，所以 &lt;code&gt;retry&lt;/code&gt; 的範例程式會產生 &lt;code&gt;SyntaxError&lt;/code&gt;(&lt;code&gt;Invalid retry&lt;/code&gt;)。改成下面這個樣子就沒問題了：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    c = &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;begin&lt;/span&gt;
      &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;for&lt;/span&gt; i &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;in&lt;/span&gt; &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;..&lt;span style=&quot;color:#00D&quot;&gt;4&lt;/span&gt;
        print i
        raise &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; i == &lt;span style=&quot;color:#00D&quot;&gt;2&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;and&lt;/span&gt; c == &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;
      &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;rescue&lt;/span&gt;
      c = &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
      print &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#b0b&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;retry&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
    print &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#b0b&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;後面那個範例和 &lt;code&gt;yield&lt;/code&gt; 在一起，要明白 &lt;code&gt;retry&lt;/code&gt; 的是哪一部分：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#06B;font-weight:bold&quot;&gt;WHILE&lt;/span&gt;(cond)
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;not&lt;/span&gt; cond
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;yield&lt;/span&gt;
        raise
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;

    i = &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;;

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;begin&lt;/span&gt;
      WHILE(i &amp;lt; &lt;span style=&quot;color:#00D&quot;&gt;3&lt;/span&gt;) { print i; i += &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; }
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;rescue&lt;/span&gt;
      &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;retry&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;不過這種使用 &lt;code&gt;retry&lt;/code&gt; 的方式很糟糕的感覺。&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>Find The Bottleneck of Programs with Gprof</title>
        <link href="http://leewings.github.io/blog/find-the-bottleneck-of-programs-with-gprof.html"/>
        <updated>2012-11-22T00:00:00+00:00</updated>
        <id>id:/blog/find-the-bottleneck-of-programs-with-gprof</id>
        <content type="html">&lt;h2 id=&quot;whats-profiling&quot;&gt;What’s Profiling&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;In software engineering, profiling (“program profiling”, “software
profiling”) is a form of dynamic program analysis that measures, for
example, of space (memory) or time complexity of program, the usage of
particular instructions, or frequency and duration of function calls. The
most common use of profiling information is to aid program optimization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;text-align:right&quot;&gt;
&amp;#8212; via &lt;a href=&quot;http://en.wikipedia.org/wiki/Software_performance_analysis&quot;&gt;Wikipedia&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&quot;whats-gprof&quot;&gt;What’s Gprof&lt;/h2&gt;

&lt;p&gt;Gprof is a performance analyzing tool, aka, profiler, which can display call
graph profile data.&lt;/p&gt;

&lt;h2 id=&quot;usage-of-gprof&quot;&gt;Usage of Gprof&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Compile the program using &lt;code&gt;gcc&lt;/code&gt; with the &lt;code&gt;-pg&lt;/code&gt; option.&lt;/li&gt;
  &lt;li&gt;Run it and get a file named &lt;code&gt;gmon.out&lt;/code&gt; containing dynamic call graph and
profile.&lt;/li&gt;
  &lt;li&gt;Run &lt;code&gt;gprof ./program&lt;/code&gt; to view the flat profile and call graph with detailed
explanation of each field.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;visualization&quot;&gt;Visualization&lt;/h2&gt;

&lt;p&gt;To visualize the output of &lt;code&gt;gprof&lt;/code&gt;, the following tools are recommended.&lt;/p&gt;

&lt;h3 id=&quot;gprof2dot&quot;&gt;&lt;a href=&quot;https://code.google.com/p/jrfonseca/wiki/Gprof2Dot&quot;&gt;Gprof2Dot&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Convert profiling output to a dot graph.&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;&lt;a href=&quot;http://www.graphviz.org&quot;&gt;Graphviz&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A package of open-source tools for drawing graphs specified in DOT language
scripts.&lt;/p&gt;

&lt;p&gt;I moved &lt;code&gt;gprof2dot.py&lt;/code&gt; to &lt;code&gt;/usr/bin&lt;/code&gt; as &lt;code&gt;gprof2dot&lt;/code&gt; for convenient, therefore,
I can generate a png or many other format file by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gprof ./program | gprof2dot | dot -Tpng -o a.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;By default gprof2dot.py generates a partial call graph, excluding nodes and
edges with little or no impact in the total computation time. If you want
the full call graph then set a zero threshold for nodes and edges via the -n
/ –node-thres and -e / –edge-thres options, as:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;gprof2dot.py -n0 -e0
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;what-about-memory-information&quot;&gt;What About Memory Information&lt;/h2&gt;

&lt;p&gt;Gprof can’t tell us about this. That’s why I need &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt;, a suite of
tools for memory debugging, memory leak detection and profiling.&lt;/p&gt;

&lt;p&gt;Memcheck is the default tool of Valgrind, so, to check memory usage and detect
memory leak, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;valgrind ./program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the other tools, cachegrind for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;valgrind --tool=cachegrind ./program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, it’s not a big deal to find the bottleneck of programs.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Compiling i386 Assembly Code on x86_64 Linux</title>
        <link href="http://leewings.github.io/blog/compiling-i386-assembly-code-on-x86_64-linux.html"/>
        <updated>2012-11-15T00:00:00+00:00</updated>
        <id>id:/blog/compiling-i386-assembly-code-on-x86_64-linux</id>
        <content type="html">&lt;p&gt;I happened to write an i386 assembly program but unfortunately, I’m
currently working on x86_64 platform Arch Linux. After reading man
pages of &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;, I finally found a way to compile and run the
program.&lt;/p&gt;

&lt;p&gt;Take the following hello world program as an example.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/5925252.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;We must select the word size of 32-bit for an i386 program while using
&lt;code&gt;as&lt;/code&gt; by adding the command line argument &lt;code&gt;--32&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as --32 -o hello.o hello.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the same reason, &lt;code&gt;-melf_i386&lt;/code&gt; must be added while using &lt;code&gt;ld&lt;/code&gt; in
order to emulate the &lt;code&gt;elf_i386&lt;/code&gt; linker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld -melf_i386 -o hello hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;file hello&lt;/code&gt; to check if we do things right.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file hello
hello: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eventually, run the target program and enjoy :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./hello
hello, world
&lt;/code&gt;&lt;/pre&gt;
</content>
    </entry>
    
    <entry>
        <title>Patch for Blahtex</title>
        <link href="http://leewings.github.io/blog/patch-for-blahtex.html"/>
        <updated>2012-11-10T00:00:00+00:00</updated>
        <id>id:/blog/patch-for-blahtex</id>
        <content type="html">&lt;p&gt;If you want to enable &lt;a href=&quot;http://maruku.rubyforge.org&quot;&gt;Maruku&lt;/a&gt;’s support of inline LaTeX-style math&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
using &lt;a href=&quot;http://gva.noekeon.org/blahtexml&quot;&gt;blahtex&lt;/a&gt;, then this patch would help.&lt;/p&gt;

&lt;p&gt;When compiling blahtex, I met the following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make blahtex-linux
mkdir -p bin-blahtex
g++ -I. -ISource -ISource/BlahtexCore -ISource/BlahtexXMLin -O2 -c
Source/main.cpp -o bin-blahtex/main.o
Source/main.cpp: In function ‘int main(int, char* const*)’:
Source/main.cpp:552:21: error: ‘isatty’ was not declared in this scope
make: *** [bin-blahtex/main.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the man page of &lt;code&gt;isatty&lt;/code&gt;, it should has &lt;code&gt;unistd.h&lt;/code&gt;
included. Another file &lt;code&gt;mainPng.cpp&lt;/code&gt; has the same problem. We can fix it
by including &lt;code&gt;unistd.h&lt;/code&gt; in both files.&lt;/p&gt;

&lt;p&gt;Here’s the patch:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/4050492.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;And for Arch Linux users, you can build from &lt;a href=&quot;https://aur.archlinux.org/packages/blahtex&quot;&gt;aur&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;More information about math support in maruku: &lt;a href=&quot;http://maruku.rubyforge.org/math.xhtml&quot;&gt;http://maruku.rubyforge.org/math.xhtml&lt;/a&gt;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
    </entry>
    
    <entry>
        <title>hello, jekyll</title>
        <link href="http://leewings.github.io/blog/hello-jekyll.html"/>
        <updated>2012-11-10T00:00:00+00:00</updated>
        <id>id:/blog/hello-jekyll</id>
        <content type="html">&lt;p&gt;Finally, I set up my first &lt;a href=&quot;https://github.com/mojombo/jekyll/&quot;&gt;Jekyll&lt;/a&gt; site on &lt;a href=&quot;http://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt; after a
few hours hacking on &lt;a href=&quot;http://mark.reid.name&quot;&gt;Mark Reid&lt;/a&gt;’s wonderful design. I hope that I
didn’t forget anything that should be modified :-)&lt;/p&gt;

&lt;p&gt;The major modifications I made were the support of &lt;a href=&quot;http://www.mathjax.org&quot;&gt;MathJax&lt;/a&gt; and the
reorganization of layouts which makes it easier to create new
categories. All codes of this site are available &lt;a href=&quot;https://github.com/leewings/leewings.github.com&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Enjoy ;-)&lt;/p&gt;
</content>
    </entry>
    

</feed>
